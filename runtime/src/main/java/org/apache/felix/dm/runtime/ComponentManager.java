/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.felix.dm.runtime;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.ArrayList;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Set;

import org.apache.felix.dm.DependencyManager;
import org.apache.felix.dm.dependencies.BundleDependency;
import org.apache.felix.dm.dependencies.ConfigurationDependency;
import org.apache.felix.dm.dependencies.Dependency;
import org.apache.felix.dm.dependencies.ResourceDependency;
import org.apache.felix.dm.dependencies.ServiceDependency;
import org.apache.felix.dm.dependencies.TemporalServiceDependency;
import org.apache.felix.dm.service.Service;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.osgi.framework.BundleEvent;
import org.osgi.framework.SynchronousBundleListener;
import org.osgi.service.log.LogService;

/**
 * This class parses service descriptors generated by the annotation bnd processor.
 * The descriptors are located under OSGI-INF/dependencymanager directory. Such files are actually 
 * referenced by a specific "DependendencyManager-Component" manifest header.
 */
public class ComponentManager implements SynchronousBundleListener
{
    private HashMap<Bundle, List<Service>> m_services = new HashMap<Bundle, List<Service>>();
    private LogService m_logService; // Injected
    private BundleContext m_bctx; // Injected
    private ServiceFactory m_serviceFactory;

    /**
     * Starts our Service (at this point, we have been injected with our bundle context, as well
     * as with our log service. We'll listen to bundle start/stop events (we implement the 
     * SynchronousBundleListener interface).
     */
    protected void start()
    {
        for (Bundle b : m_bctx.getBundles())
        {
            if (b.getState() == Bundle.ACTIVE)
            {
                bundleChanged(new BundleEvent(Bundle.ACTIVE, b));
            }
        }
        m_bctx.addBundleListener(this);
    }

    /**
     * Stops our service. We'll stop all activated DependencyManager services.
     */
    protected void stop()
    {
        for (List<Service> services : m_services.values())
        {
            for (Service service : services)
            {
                service.stop();
            }
        }
        m_services.clear();
    }

    /**
     * Handle a bundle event, and eventually parse started bundles.
     */
    public void bundleChanged(BundleEvent event)
    {
        Bundle b = event.getBundle();
        if (b.getState() == Bundle.ACTIVE)
        {
            bundleStarted(b);
        }
        else if (b.getState() == Bundle.STOPPING)
        {
            bundleStopped(b);
        }
    }

    /**
     * Checks if a started bundle have some DependencyManager descriptors 
     * referenced in the "DependencyManager-Component" OSGi header.
     * @param b the started bundle.
     */
    void bundleStarted(Bundle b)
    {
        String descriptorPaths = (String) b.getHeaders().get("DependencyManager-Component");
        if (descriptorPaths == null)
        {
            return;
        }

        for (String descriptorPath : descriptorPaths.split(","))
        {
            URL descriptorURL = b.getEntry(descriptorPath);
            if (descriptorURL == null)
            {
                m_logService.log(LogService.LOG_ERROR,
                    "DependencyManager component descriptor not found: " + descriptorPath);
                continue;
            }
            loadDescriptor(b, descriptorURL);
        }
    }

    /**
     * Load a DependencyManager component descriptor from a given bundle.
     * @param b
     * @param descriptorURL
     */
    @SuppressWarnings("null")
    private void loadDescriptor(Bundle b, URL descriptorURL)
    {
        m_logService.log(LogService.LOG_DEBUG, "Parsing descriptor " + descriptorURL
            + " from bundle " + b.getSymbolicName());

        BufferedReader in = null;
        try
        {
            DescriptorParser parser = new DescriptorParser(m_logService);
            in = new BufferedReader(new InputStreamReader(descriptorURL.openStream()));
            DependencyManager dm = new DependencyManager(b.getBundleContext());
            Service service = null;
            String line;

            while ((line = in.readLine()) != null)
            {
                Dependency dp = null;
                switch (parser.parse(line))
                {
                    case Service:
                        service = createService(b, dm, parser);
                        break;

                    case AspectService:
                        service = createAspectService(b, dm, parser);
                        break;
                        
                    case AdapterService:
                        service = createAdapterService(b, dm, parser);
                        break;
                        
                    case BundleAdapterService:
                        service = createBundleAdapterService(b, dm, parser);
                        break;

                    case ResourceAdapterService:
                        service = createResourceAdapterService(b, dm, parser);
                        break;
                        
                    case FactoryConfigurationAdapterService:
                        service = createFactoryConfigurationAdapterService(b, dm, parser);
                        break;

                    case ServiceDependency:
                        dp = createServiceDependency(b, dm, parser, false);
                        break;

                    case TemporalServiceDependency:
                        dp = createServiceDependency(b, dm, parser, true);
                        break;

                    case ConfigurationDependency:
                        dp = createConfigurationDependency(b, dm, parser);
                        break;
                        
                    case BundleDependency:
                        dp = createBundleDependency(b, dm, parser);
                        break;
                        
                    case ResourceDependency:
                        dp = createResourceDependency(b, dm, parser);
                        break;
                }
                
                // If we parsed a dependency: add it in the current parsed service, unless the service is a factory service.
                // In this case, the dependency is just buffered in the service factory, which will register it at 
                // each instantiation time.
                
                if (dp != null)
                {
                    checkServiceParsed(service);
                    if (m_serviceFactory != null)
                    {
                        // The dependency is buffered and will be used once this factory fires a service instantiation.
                        m_serviceFactory.addDependency(dp);
                    }
                    else
                    {
                        service.add(dp);
                    }
                }
            }
            
            List<Service> services = m_services.get(b);
            if (services == null)
            {
                services = new ArrayList<Service>();
                m_services.put(b, services);
            }
            services.add(service);
            dm.add(service);
        }
        catch (Throwable t)
        {
            m_logService.log(LogService.LOG_ERROR, "Error while parsing descriptor "
                + descriptorURL + " from bundle " + b.getSymbolicName(), t);
        }
        finally
        {
            if (in != null)
            {
                try
                {
                    in.close();
                }
                catch (IOException ignored)
                {
                }
            }
        }
    }

    /**
     * Unregisters all services for a stopping bundle.
     * @param b
     */
    private void bundleStopped(Bundle b)
    {
        m_logService.log(LogService.LOG_INFO, "bundle stopped: " + b.getSymbolicName());
        List<Service> services = m_services.remove(b);
        if (services != null)
        {
            for (Service s : services)
            {
                m_logService.log(LogService.LOG_INFO, "stopping service " + s);
                s.stop();
            }
        }
    }

    /**
     * Check if we have already parsed the Service entry from a given DM component descriptor file.
     * Each descriptor must start with a Service definition entry.
     * @param service the parsed service
     * @throws IllegalArgumentException if the service has not been parsed.
     */
    private void checkServiceParsed(Service service)
    {
        if (service == null)
        {
            throw new IllegalArgumentException("Service not declared in the first descriptor line");
        }
    }

    /**
     * Creates a Service that we parsed from a component descriptor entry.
     * @param b the bundle from where the service is started
     * @param dm the DependencyManager framework
     * @param parser the parser that just parsed the descriptor "Service" entry
     * @return the created DependencyManager Service
     * @throws ClassNotFoundException if the service implementation could not be instantiated
     */
    private Service createService(Bundle b, DependencyManager dm, DescriptorParser parser)
        throws ClassNotFoundException
    {
        Service service = dm.createService();
        String factory = parser.getString(DescriptorParam.factory, null);
        String factoryConfigure = parser.getString(DescriptorParam.factoryConfigure, null);
        String impl = parser.getString(DescriptorParam.impl);
        String init = parser.getString(DescriptorParam.init, null);
        String start = parser.getString(DescriptorParam.start, null);
        String stop = parser.getString(DescriptorParam.stop, null);
        String destroy = parser.getString(DescriptorParam.destroy, null);
        String composition = parser.getString(DescriptorParam.composition, null);
        Dictionary<String, String> serviceProperties = parser.getDictionary(DescriptorParam.properties, null);
        String[] provide = parser.getStrings(DescriptorParam.provide, null);

        if (factory == null)
        {
            service.setImplementation(b.loadClass(impl));
            service.setCallbacks(init, start, stop, destroy);
            if (composition != null)
            {
                service.setComposition(composition);
            }
            if (provide != null)
            {
                service.setInterface(provide, serviceProperties);
            }
        }
        else
        {
            m_serviceFactory = new ServiceFactory(b.loadClass(impl), init, start, stop, destroy,
                                                  composition, serviceProperties, provide, factoryConfigure);
            service.setImplementation(m_serviceFactory);
            service.setCallbacks(null, "start", "stop", null);
            Hashtable<String, String> props = new Hashtable<String, String>();
            props.put("dm.factory.name", factory);
            service.setInterface(Set.class.getName(), props);
        }

        return service;
    }

    /**
     * Set common Service parameters, if provided from our Component descriptor
     * @param service
     * @param parser
     */
    private void setCommonServiceParams(Service service, DescriptorParser parser)
    {
        String init = parser.getString(DescriptorParam.init, null);
        String start = parser.getString(DescriptorParam.start, null);
        String stop = parser.getString(DescriptorParam.stop, null);
        String destroy = parser.getString(DescriptorParam.destroy, null);
        service.setCallbacks(init, start, stop, destroy);
        String composition = parser.getString(DescriptorParam.composition, null);
        if (composition != null)
        {
            service.setComposition(composition);
        }
    }

    /**
     * Creates an Aspect Service.
     * @param b
     * @param dm
     * @param parser
     * @return
     */
    private Service createAspectService(Bundle b, DependencyManager dm, DescriptorParser parser)
        throws ClassNotFoundException
    {
        Service service = null;

        Class<?> serviceInterface = b.loadClass(parser.getString(DescriptorParam.service));
        String serviceFilter = parser.getString(DescriptorParam.filter, null);
        Dictionary<String, String> aspectProperties = parser.getDictionary(DescriptorParam.properties, null);
        int ranking = parser.getInt(DescriptorParam.ranking, 1);          
        String implClass = parser.getString(DescriptorParam.impl);
        Object impl = b.loadClass(implClass);
        service = dm.createAspectService(serviceInterface, serviceFilter, ranking, impl, aspectProperties);
        setCommonServiceParams(service, parser);
        return service;
    }

    /**
     * Creates an Adapter Service.
     * @param b
     * @param dm
     * @param parser
     * @return
     */
    private Service createAdapterService(Bundle b, DependencyManager dm, DescriptorParser parser)
        throws ClassNotFoundException
    {
        Class<?> adapterImpl = b.loadClass(parser.getString(DescriptorParam.impl));
        String[] adapterService = parser.getStrings(DescriptorParam.adapterService, null);
        Dictionary<String, String> adapterProperties = parser.getDictionary(DescriptorParam.adapterProperties, null);
        Class<?> adapteeService = b.loadClass(parser.getString(DescriptorParam.adapteeService));
        String adapteeFilter = parser.getString(DescriptorParam.adapteeFilter, null);     
        Service service = dm.createAdapterService(adapteeService, adapteeFilter, adapterService, adapterImpl, adapterProperties);
        setCommonServiceParams(service, parser);
        return service;
    }

    /**
     * Creates a Bundle Adapter Service.
     * @param b
     * @param dm
     * @param parser
     * @return
     */
    private Service createBundleAdapterService(Bundle b, DependencyManager dm, DescriptorParser parser)
        throws ClassNotFoundException
    {
        int stateMask = parser.getInt(DescriptorParam.stateMask, Bundle.INSTALLED | Bundle.RESOLVED | Bundle.ACTIVE);
        String filter = parser.getString(DescriptorParam.filter, null);
        Class<?> adapterImpl = b.loadClass(parser.getString(DescriptorParam.impl));
        String service = parser.getString(DescriptorParam.service, null);
        Dictionary<String, String> properties = parser.getDictionary(DescriptorParam.properties, null);
        boolean propagate = "true".equals(parser.getString(DescriptorParam.propagate, "false"));
        Service srv = dm.createBundleAdapterService(stateMask, filter, adapterImpl, service, properties, propagate);  
        setCommonServiceParams(srv, parser);
        return srv;
    }

    /**
     * Creates a Resource Adapter Service.
     * @param b
     * @param dm
     * @param parser
     * @return
     */
    private Service createResourceAdapterService(Bundle b, DependencyManager dm, DescriptorParser parser)
        throws ClassNotFoundException
    {
        String filter = parser.getString(DescriptorParam.filter, null);
        Class<?> impl = b.loadClass(parser.getString(DescriptorParam.impl));
        String service = parser.getString(DescriptorParam.service, null);
        Dictionary<String, String> properties = parser.getDictionary(DescriptorParam.properties, null);
        boolean propagate = "true".equals(parser.getString(DescriptorParam.propagate, "false"));
        Service srv = dm.createResourceAdapterService(filter, null, service, properties, impl, propagate);  
        setCommonServiceParams(srv, parser);
        return srv;
    }

    /**
     * Creates a Factory Configuration Adapter Service
     * @param b
     * @param dm
     * @param parser
     * @return
     */
    private Service createFactoryConfigurationAdapterService(Bundle b, DependencyManager dm, DescriptorParser parser)
        throws ClassNotFoundException
    {
        Class<?> impl = b.loadClass(parser.getString(DescriptorParam.impl));
        String factoryPid = parser.getString(DescriptorParam.factoryPid);
        String updated = parser.getString(DescriptorParam.updated);
        String[] services = parser.getStrings(DescriptorParam.service, null);
        Dictionary<String, String> properties = parser.getDictionary(DescriptorParam.properties, null);
        boolean propagate = "true".equals(parser.getString(DescriptorParam.propagate, "false"));
        Service srv = dm.createFactoryConfigurationAdapterService(factoryPid, updated, impl, services, properties, propagate);
        setCommonServiceParams(srv, parser);
        return srv;
    }


    /**
     * Creates a ServiceDependency that we parsed from a component descriptor "ServiceDependency" entry.
     */
    private Dependency createServiceDependency(Bundle b, DependencyManager dm, DescriptorParser parser, boolean temporal) 
        throws ClassNotFoundException
    {
        String service = parser.getString(DescriptorParam.service);
        Class<?> serviceClass = b.loadClass(service);
        String serviceFilter = parser.getString(DescriptorParam.filter, null);
        String defaultServiceImpl = parser.getString(DescriptorParam.defaultImpl, null);
        Class<?> defaultServiceImplClass = (defaultServiceImpl != null) ? b.loadClass(defaultServiceImpl) : null;
        String added = parser.getString(DescriptorParam.added, null);
        String changed = temporal ? null : parser.getString(DescriptorParam.changed, null);
        String removed = temporal ? null : parser.getString(DescriptorParam.removed, null);
        String autoConfigField = parser.getString(DescriptorParam.autoConfig, null);
        boolean required = "true".equals(parser.getString(DescriptorParam.required, "true"));
        String timeout = parser.getString(DescriptorParam.timeout, null);

        Dependency dp = createServiceDependency(dm, temporal, serviceClass, serviceFilter,
                                                defaultServiceImplClass, added, changed, removed,
                                                autoConfigField, timeout, required);
        return dp;
    }
    
    private Dependency createServiceDependency(DependencyManager dm, boolean temporal, Class<?> serviceClass,
        String serviceFilter, Class<?> defaultServiceImplClass, String added, String changed, String removed,
        String autoConfigField, String timeout, boolean required) 
    {
        ServiceDependency sd = temporal ? dm.createTemporalServiceDependency()
            : dm.createServiceDependency();
        sd.setService(serviceClass, serviceFilter);
        if (defaultServiceImplClass != null)
        {
            sd.setDefaultImplementation(defaultServiceImplClass);
        }
        sd.setCallbacks(added, changed, removed);
        if (autoConfigField != null)
        {
            sd.setAutoConfig(autoConfigField);
        }
        if (temporal)
        {
            // Set the timeout value for a temporal service dependency
            if (timeout != null)
            {
                ((TemporalServiceDependency) sd).setTimeout(Long.parseLong(timeout));
            }
            // Set required flag (always true for a temporal dependency)
            sd.setRequired(true);
        } else {
            // for ServiceDependency, get required flag.
            sd.setRequired(required);
        }
        return sd;
    }

    /**
     * Creates a ConfigurationDependency that we parsed from a component descriptor entry.
     * @param b
     * @param dm
     * @param parser
     * @return
     */
    private Dependency createConfigurationDependency(Bundle b, DependencyManager dm,
        DescriptorParser parser)
    {
        String pid = parser.getString(DescriptorParam.pid);
        boolean propagate = "true".equals(parser.getString(DescriptorParam.propagate, "false"));
        String callback = parser.getString(DescriptorParam.updated, "updated");
        Dependency dp = createConfigurationDependency(dm, pid, callback, propagate);
        return dp;
    }
    
    private Dependency createConfigurationDependency(DependencyManager dm, String pid, String callback, boolean propagate) {
        if (pid == null)
        {
            throw new IllegalArgumentException(
                "pid attribute not provided in ConfigurationDependency declaration");
        }
        ConfigurationDependency cd = dm.createConfigurationDependency();
        cd.setPid(pid);
        cd.setCallback(callback);
        cd.setPropagate(propagate);
        return cd;
    }
    
    /**
     * Creates a BundleDependency that we parsed from a component descriptor entry.
     * @param b
     * @param dm
     * @param parser
     * @return
     */
    private Dependency createBundleDependency(Bundle b, DependencyManager dm,
        DescriptorParser parser)
    {
        String added = parser.getString(DescriptorParam.added, null);
        String changed = parser.getString(DescriptorParam.changed, null);
        String removed = parser.getString(DescriptorParam.removed, null);
        boolean required = "true".equals(parser.getString(DescriptorParam.required, "true"));
        String filter = parser.getString(DescriptorParam.filter, null);
        int stateMask = parser.getInt(DescriptorParam.stateMask, -1);
        boolean propagate = "true".equals(parser.getString(DescriptorParam.propagate, "false"));
        
        Dependency dp = createBundleDependency(dm, added, changed, removed, required, propagate, filter, stateMask);
        return dp;
    }
    
    private Dependency createBundleDependency(DependencyManager dm, String added, String changed, String removed, 
        boolean required, boolean propagate, String filter, int stateMask)
    {
        BundleDependency bd = dm.createBundleDependency();
        bd.setCallbacks(added, changed, removed);
        bd.setRequired(required);
        bd.setPropagate(propagate);
        if (filter != null) 
        {
            bd.setFilter(filter);
        }
        if (stateMask != -1) 
        {
            bd.setStateMask(stateMask);
        }
        return bd;        
    }

    private Dependency createResourceDependency(@SuppressWarnings("unused") Bundle b, DependencyManager dm,
        DescriptorParser parser)
    {
        String added = parser.getString(DescriptorParam.added, null);
        String changed = parser.getString(DescriptorParam.changed, null);
        String removed = parser.getString(DescriptorParam.removed, null);
        String filter = parser.getString(DescriptorParam.filter, null);
        boolean required = "true".equals(parser.getString(DescriptorParam.required, "true"));
        boolean propagate = "true".equals(parser.getString(DescriptorParam.propagate, "false"));

        Dependency dp = createResourceDependency(dm, added, changed, removed, required, filter, propagate);
        return dp;
    }
    
    private Dependency createResourceDependency(DependencyManager dm, String added, String changed, String removed, boolean required, String filter, boolean propagate)
    {
        ResourceDependency rd = dm.createResourceDependency();
        rd.setCallbacks(added, changed, removed);
        rd.setRequired(required);
        if (filter != null) 
        {
            rd.setFilter(filter);
        }
        rd.setPropagate(propagate);
        return rd;
    }
}